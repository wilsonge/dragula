{"mappings":"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","sources":["<anon>","src/dragula.js","src/Dragula/Dragula.js","node_modules/contra/emitter.js","node_modules/atoa/atoa.js","node_modules/contra/debounce.js","node_modules/ticky/ticky-browser.js","src/Dragula/Mouse.js"],"sourcesContent":["(function () {\n\n      var $parcel$global =\n        typeof globalThis !== 'undefined'\n          ? globalThis\n          : typeof self !== 'undefined'\n          ? self\n          : typeof window !== 'undefined'\n          ? window\n          : typeof global !== 'undefined'\n          ? global\n          : {};\n  \nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\nvar $661a7c694eb6eb99$exports = {};\n\"use strict\";\nvar $9ab524b3c329eb0b$exports = {};\n$9ab524b3c329eb0b$exports = function atoa(a, n) {\n    return Array.prototype.slice.call(a, n);\n};\n\n\nvar $d4df605507cc7329$exports = {};\n\"use strict\";\nvar $0d1c62139db3c1b4$exports = {};\nvar $0d1c62139db3c1b4$var$si = typeof setImmediate === \"function\", $0d1c62139db3c1b4$var$tick;\nif ($0d1c62139db3c1b4$var$si) $0d1c62139db3c1b4$var$tick = function(fn) {\n    setImmediate(fn);\n};\nelse $0d1c62139db3c1b4$var$tick = function(fn) {\n    setTimeout(fn, 0);\n};\n$0d1c62139db3c1b4$exports = $0d1c62139db3c1b4$var$tick;\n\n\n$d4df605507cc7329$exports = function debounce(fn, args, ctx) {\n    if (!fn) return;\n    $0d1c62139db3c1b4$exports(function run() {\n        fn.apply(ctx || null, args || []);\n    });\n};\n\n\n$661a7c694eb6eb99$exports = function emitter(thing, options) {\n    var opts = options || {};\n    var evt = {};\n    if (thing === undefined) thing = {};\n    thing.on = function(type, fn) {\n        if (!evt[type]) evt[type] = [\n            fn\n        ];\n        else evt[type].push(fn);\n        return thing;\n    };\n    thing.once = function(type, fn) {\n        fn._once = true; // thing.off(fn) still works!\n        thing.on(type, fn);\n        return thing;\n    };\n    thing.off = function(type, fn) {\n        var c = arguments.length;\n        if (c === 1) delete evt[type];\n        else if (c === 0) evt = {};\n        else {\n            var et = evt[type];\n            if (!et) return thing;\n            et.splice(et.indexOf(fn), 1);\n        }\n        return thing;\n    };\n    thing.emit = function() {\n        var args = $9ab524b3c329eb0b$exports(arguments);\n        return thing.emitterSnapshot(args.shift()).apply(this, args);\n    };\n    thing.emitterSnapshot = function(type) {\n        var et = (evt[type] || []).slice(0);\n        return function() {\n            var args = $9ab524b3c329eb0b$exports(arguments);\n            var ctx = this || thing;\n            if (type === \"error\" && opts.throws !== false && !et.length) throw args.length === 1 ? args[0] : args;\n            et.forEach(function emitter(listen) {\n                if (opts.async) $d4df605507cc7329$exports(listen, args, ctx);\n                else listen.apply(ctx, args);\n                if (listen._once) thing.off(type, listen);\n            });\n            return thing;\n        };\n    };\n    return thing;\n};\n\n\n/**\n * Checks what mouse button or touch gesture was used.\n * @param {PointerEvent} e - The event\n */ // eslint-disable-next-line consistent-return\nfunction $a14468eb1aae64d2$export$2e2bcd8739ae039(e) {\n    if (e.touches !== undefined) return e.touches.length;\n    if (e.which !== undefined && e.which !== 0) return e.which;\n     // see https://github.com/bevacqua/dragula/issues/261\n    if (e.buttons !== undefined) return e.buttons;\n    const { button: button } = e;\n    if (button !== undefined) // see https://github.com/jquery/jquery/blob/99e8ff1baa7ae341e94bb89c3e84570c7c3ad9ea/src/event.js#L573-L575\n    // eslint-disable-next-line no-bitwise,no-nested-ternary\n    return button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n}\n\n\nconst $8e24812e2bcd6903$var$doc = document;\nconst { documentElement: $8e24812e2bcd6903$var$documentElement } = $8e24812e2bcd6903$var$doc;\n/**\n * Get parent of the element. If parent is the root document then null is returned\n * @param   el  {Node}\n * @returns {ParentNode|null}\n */ function $8e24812e2bcd6903$var$getParent(el) {\n    return el.parentNode === $8e24812e2bcd6903$var$doc ? null : el.parentNode;\n}\n/**\n * Get parent of the element. If parent is the root document then null is returned\n * @param   dropTarget  {Node}\n * @param   target      {Node}\n * @returns {ParentNode|null}\n */ function $8e24812e2bcd6903$var$getImmediateChild(dropTarget, target) {\n    let immediate = target;\n    while(immediate !== dropTarget && $8e24812e2bcd6903$var$getParent(immediate) !== dropTarget)immediate = $8e24812e2bcd6903$var$getParent(immediate);\n    if (immediate === $8e24812e2bcd6903$var$documentElement) return null;\n    return immediate;\n}\n/**\n * Get the next sibling of the parameter element\n * @param   el  {HTMLElement}\n * @returns boolean\n */ function $8e24812e2bcd6903$var$isEditable(el) {\n    if (!el) return false;\n     // no parents were editable\n    if (el.contentEditable === \"false\") return false;\n     // stop the lookup\n    if (el.contentEditable === \"true\") return true;\n     // found a contentEditable element in the chain\n    return $8e24812e2bcd6903$var$isEditable($8e24812e2bcd6903$var$getParent(el)); // contentEditable is set to 'inherit'\n}\n/**\n * Get the next sibling of the parameter element\n * @param   el  {HTMLElement}\n * @returns boolean\n */ function $8e24812e2bcd6903$var$isInput(el) {\n    return el.tagName === \"INPUT\" || el.tagName === \"TEXTAREA\" || el.tagName === \"SELECT\" || $8e24812e2bcd6903$var$isEditable(el);\n}\n/**\n * Get the touch target of the event. Returns the original event if it can't be computed.\n * @param   e  {TouchEvent}\n * @returns Touch|TouchEvent\n */ function $8e24812e2bcd6903$var$getEventHost(e) {\n    // on touchend event, we have to use `e.changedTouches`\n    // see http://stackoverflow.com/questions/7192563/touchend-event-properties\n    // see https://github.com/bevacqua/dragula/issues/34\n    if (e.targetTouches && e.targetTouches.length) return e.targetTouches[0];\n    if (e.changedTouches && e.changedTouches.length) return e.changedTouches[0];\n    return e;\n}\n/**\n * Gets the host co-ordinate for the event.\n * @param   coord  {string}\n * @param   e  {TouchEvent}\n * @returns Touch|TouchEvent\n */ function $8e24812e2bcd6903$var$getCoord(coord, e) {\n    const host = $8e24812e2bcd6903$var$getEventHost(e);\n    const missMap = {\n        pageX: \"clientX\",\n        // IE8\n        pageY: \"clientY\" // IE8\n    };\n    let coordinateName = coord;\n    if (coord in missMap && !(coord in host) && missMap[coord] in host) coordinateName = missMap[coord];\n    return host[coordinateName];\n}\nfunction $8e24812e2bcd6903$var$getScroll(scrollProp, offsetProp) {\n    if (typeof $parcel$global[offsetProp] !== \"undefined\") return $parcel$global[offsetProp];\n    if ($8e24812e2bcd6903$var$documentElement.clientHeight) return $8e24812e2bcd6903$var$documentElement[scrollProp];\n    return $8e24812e2bcd6903$var$doc.body[scrollProp];\n}\nfunction $8e24812e2bcd6903$var$getOffset(el) {\n    const rect = el.getBoundingClientRect();\n    return {\n        left: rect.left + $8e24812e2bcd6903$var$getScroll(\"scrollLeft\", \"pageXOffset\"),\n        top: rect.top + $8e24812e2bcd6903$var$getScroll(\"scrollTop\", \"pageYOffset\")\n    };\n}\nfunction $8e24812e2bcd6903$var$getRectWidth(rect) {\n    return rect.width || rect.right - rect.left;\n}\nfunction $8e24812e2bcd6903$var$getRectHeight(rect) {\n    return rect.height || rect.bottom - rect.top;\n}\n/**\n * Get the next sibiling of the parameter element\n * @param   el  Element\n * @returns {Element}\n */ function $8e24812e2bcd6903$var$nextEl(el) {\n    function manually() {\n        let sibling = el;\n        do sibling = sibling.nextSibling;\n        while (sibling && sibling.nodeType !== 1);\n        return sibling;\n    }\n    return el.nextElementSibling || manually();\n}\nfunction $8e24812e2bcd6903$var$getElementBehindPoint(point, x, y) {\n    // eslint-disable-next-line no-param-reassign\n    point = point || {};\n    const state = point.className || \"\";\n    // eslint-disable-next-line no-param-reassign\n    point.className += \" gu-hide\";\n    const el = $8e24812e2bcd6903$var$doc.elementFromPoint(x, y);\n    // eslint-disable-next-line no-param-reassign\n    point.className = state;\n    return el;\n}\nconst $8e24812e2bcd6903$export$ba43bf67f3d48107 = {\n    moves: ()=>true,\n    accepts: ()=>true,\n    invalid: ()=>false,\n    containers: [],\n    isContainer: ()=>false,\n    copy: false,\n    copySortSource: false,\n    revertOnSpill: false,\n    removeOnSpill: false,\n    direction: \"vertical\",\n    ignoreInputTextSelection: true,\n    mirrorContainer: $8e24812e2bcd6903$var$doc.body,\n    slideFactorX: 0,\n    slideFactorY: 0\n};\nclass $8e24812e2bcd6903$export$2e2bcd8739ae039 {\n    /**\n   * @param {Object} options - Options for dragula\n   */ constructor(options = {}){\n        this.options = {\n            ...$8e24812e2bcd6903$export$ba43bf67f3d48107,\n            ...options\n        };\n        // Ensure the drop target is init'd to be null from the start\n        this.lastDropTarget = null; // last container item was over\n        this.movementBindFn = this.startBecauseMouseMoved.bind(this);\n        this.preventGrabbedFn = this.preventGrabbed.bind(this);\n        this.grabFn = this.grab.bind(this);\n        this.releaseFn = this.release.bind(this);\n        this.dragFn = this.drag.bind(this);\n        this.drake = (0, (/*@__PURE__*/$parcel$interopDefault($661a7c694eb6eb99$exports)))({\n            containers: this.options.containers,\n            start: this.manualStart.bind(this),\n            end: this.end.bind(this),\n            cancel: this.cancel.bind(this),\n            remove: this.remove.bind(this),\n            destroy: this.destroy.bind(this),\n            canMove: this.canMove.bind(this),\n            dragging: false\n        });\n        if (this.options.removeOnSpill === true) this.drake.on(\"over\", this.spillOver.bind(this)).on(\"out\", this.spillOut.bind(this));\n    }\n    /**\n   * @param {HTMLElement }el\n   */ // eslint-disable-next-line class-methods-use-this\n    spillOver(el) {\n        el.classList.remove(\"gu-hide\");\n    }\n    /**\n   * @param {HTMLElement }el\n   */ spillOut(el) {\n        if (this.drake.dragging) el.classList.add(\"gu-hide\");\n    }\n    /**\n   * Adds the event bindings to the dom\n   * @param {boolean} remove\n   */ events(remove = false) {\n        if (remove) {\n            $8e24812e2bcd6903$var$documentElement.removeEventListener(\"pointerdown\", this.grabFn);\n            $8e24812e2bcd6903$var$documentElement.removeEventListener(\"pointerup\", this.releaseFn);\n        } else {\n            $8e24812e2bcd6903$var$documentElement.addEventListener(\"pointerdown\", this.grabFn);\n            $8e24812e2bcd6903$var$documentElement.addEventListener(\"pointerup\", this.releaseFn);\n        }\n    }\n    /**\n   * @param {Event} e - Event on grabbing an item\n   */ preventGrabbed(e) {\n        if (this.grabbed) e.preventDefault();\n    }\n    movements(remove) {\n        if (remove) $8e24812e2bcd6903$var$documentElement.removeEventListener(\"click\", this.preventGrabbedFn);\n        else $8e24812e2bcd6903$var$documentElement.addEventListener(\"click\", this.preventGrabbedFn);\n    }\n    getDrake() {\n        return this.drake;\n    }\n    /**\n   * Called when picking up an item to drag\n   * @param {PointerEvent} e - The event\n   */ grab(e) {\n        this.moveX = e.clientX;\n        this.moveY = e.clientY;\n        const ignore = (0, $a14468eb1aae64d2$export$2e2bcd8739ae039)(e) !== 1 || e.metaKey || e.ctrlKey;\n        if (ignore) return; // we only care about honest-to-god left clicks and touch events\n        const item = e.target;\n        const context = this.canStart(item);\n        if (!context) return;\n        this.grabbed = context;\n        this.eventualMovements();\n        if (e.type === \"mousedown\") {\n            if ($8e24812e2bcd6903$var$isInput(item)) // see also: https://github.com/bevacqua/dragula/issues/208\n            item.focus(); // fixes https://github.com/bevacqua/dragula/issues/176\n            else e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155\n        }\n    }\n    ungrab() {\n        this.grabbed = false;\n        this.eventualMovements(true);\n        this.movements(true);\n    }\n    release(e) {\n        this.ungrab();\n        if (!this.drake.dragging) return;\n        const item = this.copy || this.item;\n        const clientX = $8e24812e2bcd6903$var$getCoord(\"clientX\", e) || 0;\n        const clientY = $8e24812e2bcd6903$var$getCoord(\"clientY\", e) || 0;\n        const elementBehindCursor = $8e24812e2bcd6903$var$getElementBehindPoint(this.mirror, clientX, clientY);\n        const dropTarget = this.findDropTarget(elementBehindCursor, clientX, clientY);\n        // eslint-disable-next-line max-len\n        if (dropTarget && (this.copy && this.options.copySortSource || !this.copy || dropTarget !== this.source)) this.drop(item, dropTarget);\n        else if (this.options.removeOnSpill) this.remove();\n        else this.cancel();\n    }\n    eventualMovements(remove) {\n        if (remove) $8e24812e2bcd6903$var$documentElement.removeEventListener(\"pointermove\", this.movementBindFn);\n        else $8e24812e2bcd6903$var$documentElement.addEventListener(\"pointermove\", this.movementBindFn);\n    }\n    startBecauseMouseMoved(e) {\n        if (!this.grabbed) return;\n        if ((0, $a14468eb1aae64d2$export$2e2bcd8739ae039)(e) === 0) {\n            this.release({});\n            // eslint-disable-next-line max-len\n            return; // when text is selected on an input and then dragged, mouseup doesn't fire. this is our only hope\n        }\n        // truthy check fixes #239, equality fixes #207, fixes #501\n        // eslint-disable-next-line max-len\n        if (e.clientX !== undefined && Math.abs(e.clientX - this.moveX) <= this.options.slideFactorX && e.clientY !== undefined && Math.abs(e.clientY - this.moveY) <= this.options.slideFactorY) return;\n        if (this.options.ignoreInputTextSelection) {\n            const clientX = $8e24812e2bcd6903$var$getCoord(\"clientX\", e) || 0;\n            const clientY = $8e24812e2bcd6903$var$getCoord(\"clientY\", e) || 0;\n            const elementBehindCursor = $8e24812e2bcd6903$var$doc.elementFromPoint(clientX, clientY);\n            if ($8e24812e2bcd6903$var$isInput(elementBehindCursor)) return;\n        }\n        const { grabbed: grabbed } = this; // call to end() unsets _grabbed\n        this.eventualMovements(true);\n        this.movements();\n        this.end();\n        this.start(grabbed);\n        const offset = $8e24812e2bcd6903$var$getOffset(this.item);\n        this.offsetX = $8e24812e2bcd6903$var$getCoord(\"pageX\", e) - offset.left;\n        this.offsetY = $8e24812e2bcd6903$var$getCoord(\"pageY\", e) - offset.top;\n        const item = this.copy || this.item;\n        item.classList.add(\"gu-transit\");\n        this.renderMirrorImage();\n        this.drag(e);\n    }\n    drag(e) {\n        if (!this.mirror) return;\n        e.preventDefault();\n        const clientX = $8e24812e2bcd6903$var$getCoord(\"clientX\", e) || 0;\n        const clientY = $8e24812e2bcd6903$var$getCoord(\"clientY\", e) || 0;\n        const x = clientX - this.offsetX;\n        const y = clientY - this.offsetY;\n        this.mirror.style.left = `${x}px`;\n        this.mirror.style.top = `${y}px`;\n        const item = this.copy || this.item;\n        const elementBehindCursor = $8e24812e2bcd6903$var$getElementBehindPoint(this.mirror, clientX, clientY);\n        let dropTarget = this.findDropTarget(elementBehindCursor, clientX, clientY);\n        const changed = dropTarget !== null && dropTarget !== this.lastDropTarget;\n        if (changed || dropTarget === null) {\n            if (this.lastDropTarget) this.drake.emit(\"out\", item, this.lastDropTarget, this.source);\n            this.lastDropTarget = dropTarget;\n            if (changed) this.drake.emit(\"over\", item, this.lastDropTarget, this.source);\n        }\n        const parent = $8e24812e2bcd6903$var$getParent(item);\n        if (dropTarget === this.source && this.copy && !this.options.copySortSource) {\n            if (parent) parent.removeChild(item);\n            return;\n        }\n        let reference;\n        const immediate = $8e24812e2bcd6903$var$getImmediateChild(dropTarget, elementBehindCursor);\n        if (immediate !== null) reference = this.getReference(dropTarget, immediate, clientX, clientY);\n        else if (this.options.revertOnSpill === true && !this.copy) {\n            reference = this.initialSibling;\n            dropTarget = this.source;\n        } else {\n            if (this.copy && parent) parent.removeChild(item);\n            return;\n        }\n        if (reference === null && changed || reference !== item && reference !== $8e24812e2bcd6903$var$nextEl(item)) {\n            this.currentSibling = reference;\n            dropTarget.insertBefore(item, reference);\n            this.drake.emit(\"shadow\", item, dropTarget, this.source);\n        }\n    }\n    renderMirrorImage() {\n        if (this.mirror) return;\n        const rect = this.item.getBoundingClientRect();\n        this.mirror = this.item.cloneNode(true);\n        this.mirror.style.width = `${$8e24812e2bcd6903$var$getRectWidth(rect)}px`;\n        this.mirror.style.height = `${$8e24812e2bcd6903$var$getRectHeight(rect)}px`;\n        this.mirror.classList.remove(\"gu-transit\");\n        this.mirror.classList.add(\"gu-mirror\");\n        this.options.mirrorContainer.appendChild(this.mirror);\n        $8e24812e2bcd6903$var$documentElement.addEventListener(\"pointermove\", this.dragFn);\n        this.options.mirrorContainer.classList.add(\"gu-unselectable\");\n        this.drake.emit(\"cloned\", this.mirror, this.item, \"mirror\");\n    }\n    removeMirrorImage() {\n        if (this.mirror) {\n            this.options.mirrorContainer.classList.remove(\"gu-unselectable\");\n            $8e24812e2bcd6903$var$documentElement.removeEventListener(\"pointermove\", this.dragFn);\n            $8e24812e2bcd6903$var$getParent(this.mirror).removeChild(this.mirror);\n            this.mirror = null;\n        }\n    }\n    start(context) {\n        if (this.isCopy(context.item, context.source)) {\n            this.copy = context.item.cloneNode(true);\n            this.drake.emit(\"cloned\", this.copy, context.item, \"copy\");\n        }\n        this.source = context.source;\n        this.item = context.item;\n        this.initialSibling = $8e24812e2bcd6903$var$nextEl(context.item);\n        this.currentSibling = $8e24812e2bcd6903$var$nextEl(context.item);\n        this.drake.dragging = true;\n        this.drake.emit(\"drag\", this.item, this.source);\n    }\n    end() {\n        if (!this.drake.dragging) return;\n        const item = this.copy || this.item;\n        this.drop(item, $8e24812e2bcd6903$var$getParent(item));\n    }\n    cancel(revert) {\n        if (!this.drake.dragging) return;\n        const reverts = arguments.length > 0 ? revert : this.options.revertOnSpill;\n        const item = this.copy || this.item;\n        const parent = $8e24812e2bcd6903$var$getParent(item);\n        const initial = this.isInitialPlacement(parent);\n        if (initial === false && reverts) {\n            if (this.copy) {\n                if (parent) parent.removeChild(this.copy);\n            } else this.source.insertBefore(item, this.initialSibling);\n        }\n        if (initial || reverts) this.drake.emit(\"cancel\", item, this.source, this.source);\n        else this.drake.emit(\"drop\", item, parent, this.source, this.currentSibling);\n        this.cleanup();\n    }\n    cleanup() {\n        const item = this.copy || this.item;\n        this.ungrab();\n        this.removeMirrorImage();\n        if (item) item.classList.remove(\"gu-transit\");\n        this.drake.dragging = false;\n        if (this.lastDropTarget) this.drake.emit(\"out\", item, this.lastDropTarget, this.source);\n        this.drake.emit(\"dragend\", item);\n        // eslint-disable-next-line max-len,no-multi-assign\n        this.source = this.item = this.copy = this.initialSibling = this.currentSibling = this.lastDropTarget = null;\n    }\n    isCopy(item, container) {\n        return typeof this.options.copy === \"boolean\" ? this.options.copy : this.options.copy(item, container);\n    }\n    isContainer(el) {\n        return this.drake.containers.indexOf(el) !== -1 || this.options.isContainer(el);\n    }\n    findDropTarget(elementBehindCursor, clientX, clientY) {\n        let target = elementBehindCursor;\n        while(target && !this.isDropTargetAccepted(target, elementBehindCursor, clientX, clientY))target = $8e24812e2bcd6903$var$getParent(target);\n        return target;\n    }\n    isDropTargetAccepted(target, originalTarget, clientX, clientY) {\n        const droppable = this.isContainer(target);\n        if (droppable === false) return false;\n        const immediate = $8e24812e2bcd6903$var$getImmediateChild(target, originalTarget);\n        const reference = this.getReference(target, immediate, clientX, clientY);\n        const initial = this.isInitialPlacement(target, reference);\n        if (initial) return true; // should always be able to drop it right back where it was\n        return this.options.accepts(this.item, target, this.source, reference);\n    }\n    isInitialPlacement(target, s) {\n        let sibling;\n        if (s !== undefined) sibling = s;\n        else if (this.mirror) sibling = this.currentSibling;\n        else sibling = $8e24812e2bcd6903$var$nextEl(this.copy || this.item);\n        return target === this.source && sibling === this.initialSibling;\n    }\n    getReference(dropTarget, target, x, y) {\n        const horizontal = this.options.direction === \"horizontal\";\n        function resolve(after) {\n            return after ? $8e24812e2bcd6903$var$nextEl(target) : target;\n        }\n        function outside() {\n            // slower, but able to figure out any position\n            const { children: children } = dropTarget;\n            const len = children.length;\n            let el;\n            let rect;\n            // eslint-disable-next-line no-plusplus\n            for(let i = 0; i < len; i++){\n                el = children[i];\n                rect = el.getBoundingClientRect();\n                if (horizontal && rect.left + rect.width / 2 > x) return el;\n                if (!horizontal && rect.top + rect.height / 2 > y) return el;\n            }\n            return null;\n        }\n        function inside() {\n            // faster, but only available if dropped inside a child element\n            const rect = target.getBoundingClientRect();\n            if (horizontal) return resolve(x > rect.left + $8e24812e2bcd6903$var$getRectWidth(rect) / 2);\n            return resolve(y > rect.top + $8e24812e2bcd6903$var$getRectHeight(rect) / 2);\n        }\n        return target !== dropTarget ? inside() : outside();\n    }\n    /**\n   * @param {Node} item - The item being checked\n   */ canStart(item) {\n        if (this.drake.dragging && this.mirror) return;\n        if (this.isContainer(item)) return; // don't drag container itself\n        const handle = item;\n        while($8e24812e2bcd6903$var$getParent(item) && this.isContainer($8e24812e2bcd6903$var$getParent(item)) === false){\n            if (this.options.invalid(item, handle)) return;\n            // eslint-disable-next-line no-param-reassign\n            item = $8e24812e2bcd6903$var$getParent(item); // drag target should be a top element\n            if (!item) return;\n        }\n        const source = $8e24812e2bcd6903$var$getParent(item);\n        if (!source) return;\n        if (this.options.invalid(item, handle)) return;\n        const movable = this.options.moves(item, source, handle, $8e24812e2bcd6903$var$nextEl(item));\n        if (!movable) return;\n        // eslint-disable-next-line consistent-return\n        return {\n            item: item,\n            source: source\n        };\n    }\n    drop(item, target) {\n        const parent = $8e24812e2bcd6903$var$getParent(item);\n        if (this.copy && this.options.copySortSource && target === this.source) parent.removeChild(this.item);\n        if (this.isInitialPlacement(target)) this.drake.emit(\"cancel\", item, this.source, this.source);\n        else this.drake.emit(\"drop\", item, target, this.source, this.currentSibling);\n        this.cleanup();\n    }\n    canMove(item) {\n        return !!this.canStart(item);\n    }\n    remove() {\n        if (!this.drake.dragging) return;\n        const item = this.copy || this.item;\n        const parent = $8e24812e2bcd6903$var$getParent(item);\n        if (parent) parent.removeChild(item);\n        this.drake.emit(this.copy ? \"cancel\" : \"remove\", item, parent, this.source);\n        this.cleanup();\n    }\n    destroy() {\n        this.events(true);\n        this.release({});\n    }\n    manualStart(item) {\n        const context = this.canStart(item);\n        if (context) this.start(context);\n    }\n}\n\n\nwindow.dragula = (initialContainers, options)=>{\n    if (options === undefined && Array.isArray(initialContainers) === false) // eslint-disable-next-line no-param-reassign\n    options = initialContainers;\n    else if (Array.isArray(initialContainers)) {\n        if (options === undefined) // eslint-disable-next-line no-param-reassign\n        options = {};\n        if (Object.prototype.hasOwnProperty.call(options, \"containers\") === false) // eslint-disable-next-line no-param-reassign\n        options.containers = initialContainers;\n    }\n    const dragulaObject = new (0, $8e24812e2bcd6903$export$2e2bcd8739ae039)(options);\n    dragulaObject.events();\n    return dragulaObject.getDrake();\n};\n\n})();\n//# sourceMappingURL=dragula-min.js.map\n","import Dragula from './Dragula/Dragula';\n\nwindow.dragula = (initialContainers, options) => {\n  if (options === undefined && Array.isArray(initialContainers) === false) {\n    // eslint-disable-next-line no-param-reassign\n    options = initialContainers;\n  } else if (Array.isArray(initialContainers)) {\n    if (options === undefined) {\n      // eslint-disable-next-line no-param-reassign\n      options = {};\n    }\n    if (Object.prototype.hasOwnProperty.call(options, 'containers') === false) {\n      // eslint-disable-next-line no-param-reassign\n      options.containers = initialContainers;\n    }\n  }\n\n  const dragulaObject = new Dragula(options);\n  dragulaObject.events();\n  return dragulaObject.getDrake();\n};\n","import emitter from 'contra/emitter';\nimport whichMouseButton from './Mouse';\n\nconst doc = document;\nconst { documentElement } = doc;\n\n/**\n * Get parent of the element. If parent is the root document then null is returned\n * @param   el  {Node}\n * @returns {ParentNode|null}\n */\nfunction getParent(el) { return el.parentNode === doc ? null : el.parentNode; }\n\n/**\n * Get parent of the element. If parent is the root document then null is returned\n * @param   dropTarget  {Node}\n * @param   target      {Node}\n * @returns {ParentNode|null}\n */\nfunction getImmediateChild(dropTarget, target) {\n  let immediate = target;\n  while (immediate !== dropTarget && getParent(immediate) !== dropTarget) {\n    immediate = getParent(immediate);\n  }\n  if (immediate === documentElement) {\n    return null;\n  }\n  return immediate;\n}\n\n/**\n * Get the next sibling of the parameter element\n * @param   el  {HTMLElement}\n * @returns boolean\n */\nfunction isEditable(el) {\n  if (!el) { return false; } // no parents were editable\n  if (el.contentEditable === 'false') { return false; } // stop the lookup\n  if (el.contentEditable === 'true') { return true; } // found a contentEditable element in the chain\n  return isEditable(getParent(el)); // contentEditable is set to 'inherit'\n}\n\n/**\n * Get the next sibling of the parameter element\n * @param   el  {HTMLElement}\n * @returns boolean\n */\nfunction isInput(el) { return el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || isEditable(el); }\n\n/**\n * Get the touch target of the event. Returns the original event if it can't be computed.\n * @param   e  {TouchEvent}\n * @returns Touch|TouchEvent\n */\nfunction getEventHost(e) {\n  // on touchend event, we have to use `e.changedTouches`\n  // see http://stackoverflow.com/questions/7192563/touchend-event-properties\n  // see https://github.com/bevacqua/dragula/issues/34\n  if (e.targetTouches && e.targetTouches.length) {\n    return e.targetTouches[0];\n  }\n  if (e.changedTouches && e.changedTouches.length) {\n    return e.changedTouches[0];\n  }\n  return e;\n}\n\n/**\n * Gets the host co-ordinate for the event.\n * @param   coord  {string}\n * @param   e  {TouchEvent}\n * @returns Touch|TouchEvent\n */\nfunction getCoord(coord, e) {\n  const host = getEventHost(e);\n  const missMap = {\n    pageX: 'clientX', // IE8\n    pageY: 'clientY', // IE8\n  };\n  let coordinateName = coord;\n  if (coord in missMap && !(coord in host) && missMap[coord] in host) {\n    coordinateName = missMap[coord];\n  }\n  return host[coordinateName];\n}\n\nfunction getScroll(scrollProp, offsetProp) {\n  if (typeof global[offsetProp] !== 'undefined') {\n    return global[offsetProp];\n  }\n  if (documentElement.clientHeight) {\n    return documentElement[scrollProp];\n  }\n  return doc.body[scrollProp];\n}\n\nfunction getOffset(el) {\n  const rect = el.getBoundingClientRect();\n  return {\n    left: rect.left + getScroll('scrollLeft', 'pageXOffset'),\n    top: rect.top + getScroll('scrollTop', 'pageYOffset'),\n  };\n}\n\nfunction getRectWidth(rect) { return rect.width || (rect.right - rect.left); }\nfunction getRectHeight(rect) { return rect.height || (rect.bottom - rect.top); }\n\n/**\n * Get the next sibiling of the parameter element\n * @param   el  Element\n * @returns {Element}\n */\nfunction nextEl(el) {\n  function manually() {\n    let sibling = el;\n    do {\n      sibling = sibling.nextSibling;\n    } while (sibling && sibling.nodeType !== 1);\n    return sibling;\n  }\n  return el.nextElementSibling || manually();\n}\n\nfunction getElementBehindPoint(point, x, y) {\n  // eslint-disable-next-line no-param-reassign\n  point = point || {};\n  const state = point.className || '';\n  // eslint-disable-next-line no-param-reassign\n  point.className += ' gu-hide';\n  const el = doc.elementFromPoint(x, y);\n  // eslint-disable-next-line no-param-reassign\n  point.className = state;\n  return el;\n}\n\n/**\n * Default Options for Dragula\n * @property  {function(): boolean} moves\n * @property  {function(): boolean} accepts\n * @property  {function(): boolean} invalid\n * @property  {HTMLElement[]}\n * @property  {function(): boolean} isContainer\n * @property  {boolean|function(): boolean} copy\n * @property  {boolean} copySortSource\n * @property  {boolean} revertOnSpill\n * @property  {boolean} removeOnSpill\n * @property  {string}  direction\n * @property  {boolean} ignoreInputTextSelection\n * @property  {HTMLElement} mirrorContainer\n * @property  {int} slideFactorX\n * @property  {int} slideFactorY\n */\nexport const defaultOptions = {\n  moves: () => true,\n  accepts: () => true,\n  invalid: () => false,\n  containers: [],\n  isContainer: () => false,\n  copy: false,\n  copySortSource: false,\n  revertOnSpill: false,\n  removeOnSpill: false,\n  direction: 'vertical',\n  ignoreInputTextSelection: true,\n  mirrorContainer: doc.body,\n  slideFactorX: 0,\n  slideFactorY: 0,\n};\n\n/**\n * @property {Node} mirror   The mirror image\n * @property {Node} source   The source container\n * @property {Node} item     The item being dragged\n * @property {int}  offsetX  The reference x\n * @property {int}  moveX    The reference move x\n * @property {int}  moveY    The reference move y\n * @property {Element}  initialSibling    The reference sibling when grabbed\n * @property {Element}  currentSibling    The reference sibling now\n * @property {Node}  copy    The item used for copying\n * @property {?Object}  grabbed    Holds mousedown context until first mousemove\n */\nexport default class Dragula {\n  /**\n   * @param {Object} options - Options for dragula\n   */\n  constructor(options = {}) {\n    this.options = {\n      ...defaultOptions,\n      ...options,\n    };\n\n    // Ensure the drop target is init'd to be null from the start\n    this.lastDropTarget = null; // last container item was over\n    this.movementBindFn = this.startBecauseMouseMoved.bind(this);\n    this.preventGrabbedFn = this.preventGrabbed.bind(this);\n    this.grabFn = this.grab.bind(this);\n    this.releaseFn = this.release.bind(this);\n    this.dragFn = this.drag.bind(this);\n\n    this.drake = emitter({\n      containers: this.options.containers,\n      start: this.manualStart.bind(this),\n      end: this.end.bind(this),\n      cancel: this.cancel.bind(this),\n      remove: this.remove.bind(this),\n      destroy: this.destroy.bind(this),\n      canMove: this.canMove.bind(this),\n      dragging: false,\n    });\n\n    if (this.options.removeOnSpill === true) {\n      this.drake.on('over', this.spillOver.bind(this)).on('out', this.spillOut.bind(this));\n    }\n  }\n\n  /**\n   * @param {HTMLElement }el\n   */\n  // eslint-disable-next-line class-methods-use-this\n  spillOver(el) {\n    el.classList.remove('gu-hide');\n  }\n\n  /**\n   * @param {HTMLElement }el\n   */\n  spillOut(el) {\n    if (this.drake.dragging) { el.classList.add('gu-hide'); }\n  }\n\n  /**\n   * Adds the event bindings to the dom\n   * @param {boolean} remove\n   */\n  events(remove = false) {\n    if (remove) {\n      documentElement.removeEventListener('pointerdown', this.grabFn);\n      documentElement.removeEventListener('pointerup', this.releaseFn);\n    } else {\n      documentElement.addEventListener('pointerdown', this.grabFn);\n      documentElement.addEventListener('pointerup', this.releaseFn);\n    }\n  }\n\n  /**\n   * @param {Event} e - Event on grabbing an item\n   */\n  preventGrabbed(e) {\n    if (this.grabbed) {\n      e.preventDefault();\n    }\n  }\n\n  movements(remove) {\n    if (remove) {\n      documentElement.removeEventListener('click', this.preventGrabbedFn);\n    } else {\n      documentElement.addEventListener('click', this.preventGrabbedFn);\n    }\n  }\n\n  getDrake() {\n    return this.drake;\n  }\n\n  /**\n   * Called when picking up an item to drag\n   * @param {PointerEvent} e - The event\n   */\n  grab(e) {\n    this.moveX = e.clientX;\n    this.moveY = e.clientY;\n\n    const ignore = whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey;\n    if (ignore) {\n      return; // we only care about honest-to-god left clicks and touch events\n    }\n    const item = e.target;\n    const context = this.canStart(item);\n    if (!context) {\n      return;\n    }\n    this.grabbed = context;\n    this.eventualMovements();\n    if (e.type === 'mousedown') {\n      if (isInput(item)) { // see also: https://github.com/bevacqua/dragula/issues/208\n        item.focus(); // fixes https://github.com/bevacqua/dragula/issues/176\n      } else {\n        e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155\n      }\n    }\n  }\n\n  ungrab() {\n    this.grabbed = false;\n    this.eventualMovements(true);\n    this.movements(true);\n  }\n\n  release(e) {\n    this.ungrab();\n\n    if (!this.drake.dragging) {\n      return;\n    }\n    const item = this.copy || this.item;\n    const clientX = getCoord('clientX', e) || 0;\n    const clientY = getCoord('clientY', e) || 0;\n    const elementBehindCursor = getElementBehindPoint(this.mirror, clientX, clientY);\n    const dropTarget = this.findDropTarget(elementBehindCursor, clientX, clientY);\n\n    // eslint-disable-next-line max-len\n    if (dropTarget && ((this.copy && this.options.copySortSource) || (!this.copy || dropTarget !== this.source))) {\n      this.drop(item, dropTarget);\n    } else if (this.options.removeOnSpill) {\n      this.remove();\n    } else {\n      this.cancel();\n    }\n  }\n\n  eventualMovements(remove) {\n    if (remove) {\n      documentElement.removeEventListener('pointermove', this.movementBindFn);\n    } else {\n      documentElement.addEventListener('pointermove', this.movementBindFn);\n    }\n  }\n\n  startBecauseMouseMoved(e) {\n    if (!this.grabbed) {\n      return;\n    }\n    if (whichMouseButton(e) === 0) {\n      this.release({});\n      // eslint-disable-next-line max-len\n      return; // when text is selected on an input and then dragged, mouseup doesn't fire. this is our only hope\n    }\n\n    // truthy check fixes #239, equality fixes #207, fixes #501\n    // eslint-disable-next-line max-len\n    if ((e.clientX !== undefined && Math.abs(e.clientX - this.moveX) <= this.options.slideFactorX)\n      // eslint-disable-next-line max-len\n      && (e.clientY !== undefined && Math.abs(e.clientY - this.moveY) <= this.options.slideFactorY)) {\n      return;\n    }\n\n    if (this.options.ignoreInputTextSelection) {\n      const clientX = getCoord('clientX', e) || 0;\n      const clientY = getCoord('clientY', e) || 0;\n      const elementBehindCursor = doc.elementFromPoint(clientX, clientY);\n      if (isInput(elementBehindCursor)) {\n        return;\n      }\n    }\n\n    const { grabbed } = this; // call to end() unsets _grabbed\n    this.eventualMovements(true);\n    this.movements();\n    this.end();\n    this.start(grabbed);\n\n    const offset = getOffset(this.item);\n    this.offsetX = getCoord('pageX', e) - offset.left;\n    this.offsetY = getCoord('pageY', e) - offset.top;\n\n    const item = this.copy || this.item;\n    item.classList.add('gu-transit');\n    this.renderMirrorImage();\n    this.drag(e);\n  }\n\n  drag(e) {\n    if (!this.mirror) {\n      return;\n    }\n    e.preventDefault();\n\n    const clientX = getCoord('clientX', e) || 0;\n    const clientY = getCoord('clientY', e) || 0;\n    const x = clientX - this.offsetX;\n    const y = clientY - this.offsetY;\n\n    this.mirror.style.left = `${x}px`;\n    this.mirror.style.top = `${y}px`;\n\n    const item = this.copy || this.item;\n    const elementBehindCursor = getElementBehindPoint(this.mirror, clientX, clientY);\n    let dropTarget = this.findDropTarget(elementBehindCursor, clientX, clientY);\n    const changed = dropTarget !== null && dropTarget !== this.lastDropTarget;\n\n    if (changed || dropTarget === null) {\n      if (this.lastDropTarget) { this.drake.emit('out', item, this.lastDropTarget, this.source); }\n      this.lastDropTarget = dropTarget;\n      if (changed) { this.drake.emit('over', item, this.lastDropTarget, this.source); }\n    }\n    const parent = getParent(item);\n    if (dropTarget === this.source && this.copy && !this.options.copySortSource) {\n      if (parent) {\n        parent.removeChild(item);\n      }\n      return;\n    }\n    let reference;\n    const immediate = getImmediateChild(dropTarget, elementBehindCursor);\n    if (immediate !== null) {\n      reference = this.getReference(dropTarget, immediate, clientX, clientY);\n    } else if (this.options.revertOnSpill === true && !this.copy) {\n      reference = this.initialSibling;\n      dropTarget = this.source;\n    } else {\n      if (this.copy && parent) {\n        parent.removeChild(item);\n      }\n      return;\n    }\n    if (\n      (reference === null && changed)\n       || (reference !== item && reference !== nextEl(item))\n    ) {\n      this.currentSibling = reference;\n      dropTarget.insertBefore(item, reference);\n      this.drake.emit('shadow', item, dropTarget, this.source);\n    }\n  }\n\n  renderMirrorImage() {\n    if (this.mirror) {\n      return;\n    }\n    const rect = this.item.getBoundingClientRect();\n    this.mirror = this.item.cloneNode(true);\n    this.mirror.style.width = `${getRectWidth(rect)}px`;\n    this.mirror.style.height = `${getRectHeight(rect)}px`;\n    this.mirror.classList.remove('gu-transit');\n    this.mirror.classList.add('gu-mirror');\n    this.options.mirrorContainer.appendChild(this.mirror);\n    documentElement.addEventListener('pointermove', this.dragFn);\n    this.options.mirrorContainer.classList.add('gu-unselectable');\n    this.drake.emit('cloned', this.mirror, this.item, 'mirror');\n  }\n\n  removeMirrorImage() {\n    if (this.mirror) {\n      this.options.mirrorContainer.classList.remove('gu-unselectable');\n      documentElement.removeEventListener('pointermove', this.dragFn);\n      getParent(this.mirror).removeChild(this.mirror);\n      this.mirror = null;\n    }\n  }\n\n  start(context) {\n    if (this.isCopy(context.item, context.source)) {\n      this.copy = context.item.cloneNode(true);\n      this.drake.emit('cloned', this.copy, context.item, 'copy');\n    }\n\n    this.source = context.source;\n    this.item = context.item;\n    this.initialSibling = nextEl(context.item);\n    this.currentSibling = nextEl(context.item);\n\n    this.drake.dragging = true;\n    this.drake.emit('drag', this.item, this.source);\n  }\n\n  end() {\n    if (!this.drake.dragging) {\n      return;\n    }\n    const item = this.copy || this.item;\n    this.drop(item, getParent(item));\n  }\n\n  cancel(revert) {\n    if (!this.drake.dragging) {\n      return;\n    }\n    const reverts = arguments.length > 0 ? revert : this.options.revertOnSpill;\n    const item = this.copy || this.item;\n    const parent = getParent(item);\n    const initial = this.isInitialPlacement(parent);\n    if (initial === false && reverts) {\n      if (this.copy) {\n        if (parent) {\n          parent.removeChild(this.copy);\n        }\n      } else {\n        this.source.insertBefore(item, this.initialSibling);\n      }\n    }\n    if (initial || reverts) {\n      this.drake.emit('cancel', item, this.source, this.source);\n    } else {\n      this.drake.emit('drop', item, parent, this.source, this.currentSibling);\n    }\n    this.cleanup();\n  }\n\n  cleanup() {\n    const item = this.copy || this.item;\n    this.ungrab();\n    this.removeMirrorImage();\n    if (item) {\n      item.classList.remove('gu-transit');\n    }\n    this.drake.dragging = false;\n    if (this.lastDropTarget) {\n      this.drake.emit('out', item, this.lastDropTarget, this.source);\n    }\n    this.drake.emit('dragend', item);\n    // eslint-disable-next-line max-len,no-multi-assign\n    this.source = this.item = this.copy = this.initialSibling = this.currentSibling = this.lastDropTarget = null;\n  }\n\n  isCopy(item, container) {\n    return typeof this.options.copy === 'boolean' ? this.options.copy : this.options.copy(item, container);\n  }\n\n  isContainer(el) {\n    return this.drake.containers.indexOf(el) !== -1 || this.options.isContainer(el);\n  }\n\n  findDropTarget(elementBehindCursor, clientX, clientY) {\n    let target = elementBehindCursor;\n\n    while (target && !this.isDropTargetAccepted(target, elementBehindCursor, clientX, clientY)) {\n      target = getParent(target);\n    }\n    return target;\n  }\n\n  isDropTargetAccepted(target, originalTarget, clientX, clientY) {\n    const droppable = this.isContainer(target);\n    if (droppable === false) {\n      return false;\n    }\n\n    const immediate = getImmediateChild(target, originalTarget);\n    const reference = this.getReference(target, immediate, clientX, clientY);\n    const initial = this.isInitialPlacement(target, reference);\n    if (initial) {\n      return true; // should always be able to drop it right back where it was\n    }\n    return this.options.accepts(this.item, target, this.source, reference);\n  }\n\n  isInitialPlacement(target, s) {\n    let sibling;\n    if (s !== undefined) {\n      sibling = s;\n    } else if (this.mirror) {\n      sibling = this.currentSibling;\n    } else {\n      sibling = nextEl(this.copy || this.item);\n    }\n    return target === this.source && sibling === this.initialSibling;\n  }\n\n  getReference(dropTarget, target, x, y) {\n    const horizontal = this.options.direction === 'horizontal';\n\n    function resolve(after) {\n      return after ? nextEl(target) : target;\n    }\n\n    function outside() { // slower, but able to figure out any position\n      const { children } = dropTarget;\n      const len = children.length;\n      let el;\n      let rect;\n      // eslint-disable-next-line no-plusplus\n      for (let i = 0; i < len; i++) {\n        el = children[i];\n        rect = el.getBoundingClientRect();\n        if (horizontal && (rect.left + rect.width / 2) > x) { return el; }\n        if (!horizontal && (rect.top + rect.height / 2) > y) { return el; }\n      }\n      return null;\n    }\n\n    function inside() { // faster, but only available if dropped inside a child element\n      const rect = target.getBoundingClientRect();\n      if (horizontal) {\n        return resolve(x > rect.left + getRectWidth(rect) / 2);\n      }\n      return resolve(y > rect.top + getRectHeight(rect) / 2);\n    }\n\n    return target !== dropTarget ? inside() : outside();\n  }\n\n  /**\n   * @param {Node} item - The item being checked\n   */\n  canStart(item) {\n    if (this.drake.dragging && this.mirror) {\n      return;\n    }\n    if (this.isContainer(item)) {\n      return; // don't drag container itself\n    }\n    const handle = item;\n    while (getParent(item) && this.isContainer(getParent(item)) === false) {\n      if (this.options.invalid(item, handle)) {\n        return;\n      }\n      // eslint-disable-next-line no-param-reassign\n      item = getParent(item); // drag target should be a top element\n      if (!item) {\n        return;\n      }\n    }\n    const source = getParent(item);\n    if (!source) {\n      return;\n    }\n    if (this.options.invalid(item, handle)) {\n      return;\n    }\n\n    const movable = this.options.moves(item, source, handle, nextEl(item));\n    if (!movable) {\n      return;\n    }\n\n    // eslint-disable-next-line consistent-return\n    return {\n      item,\n      source,\n    };\n  }\n\n  drop(item, target) {\n    const parent = getParent(item);\n    if (this.copy && this.options.copySortSource && target === this.source) {\n      parent.removeChild(this.item);\n    }\n    if (this.isInitialPlacement(target)) {\n      this.drake.emit('cancel', item, this.source, this.source);\n    } else {\n      this.drake.emit('drop', item, target, this.source, this.currentSibling);\n    }\n    this.cleanup();\n  }\n\n  canMove(item) {\n    return !!this.canStart(item);\n  }\n\n  remove() {\n    if (!this.drake.dragging) {\n      return;\n    }\n    const item = this.copy || this.item;\n    const parent = getParent(item);\n    if (parent) {\n      parent.removeChild(item);\n    }\n    this.drake.emit(this.copy ? 'cancel' : 'remove', item, parent, this.source);\n    this.cleanup();\n  }\n\n  destroy() {\n    this.events(true);\n    this.release({});\n  }\n\n  manualStart(item) {\n    const context = this.canStart(item);\n    if (context) {\n      this.start(context);\n    }\n  }\n}\n","'use strict';\n\nvar atoa = require('atoa');\nvar debounce = require('./debounce');\n\nmodule.exports = function emitter (thing, options) {\n  var opts = options || {};\n  var evt = {};\n  if (thing === undefined) { thing = {}; }\n  thing.on = function (type, fn) {\n    if (!evt[type]) {\n      evt[type] = [fn];\n    } else {\n      evt[type].push(fn);\n    }\n    return thing;\n  };\n  thing.once = function (type, fn) {\n    fn._once = true; // thing.off(fn) still works!\n    thing.on(type, fn);\n    return thing;\n  };\n  thing.off = function (type, fn) {\n    var c = arguments.length;\n    if (c === 1) {\n      delete evt[type];\n    } else if (c === 0) {\n      evt = {};\n    } else {\n      var et = evt[type];\n      if (!et) { return thing; }\n      et.splice(et.indexOf(fn), 1);\n    }\n    return thing;\n  };\n  thing.emit = function () {\n    var args = atoa(arguments);\n    return thing.emitterSnapshot(args.shift()).apply(this, args);\n  };\n  thing.emitterSnapshot = function (type) {\n    var et = (evt[type] || []).slice(0);\n    return function () {\n      var args = atoa(arguments);\n      var ctx = this || thing;\n      if (type === 'error' && opts.throws !== false && !et.length) { throw args.length === 1 ? args[0] : args; }\n      et.forEach(function emitter (listen) {\n        if (opts.async) { debounce(listen, args, ctx); } else { listen.apply(ctx, args); }\n        if (listen._once) { thing.off(type, listen); }\n      });\n      return thing;\n    };\n  };\n  return thing;\n};\n","module.exports = function atoa (a, n) { return Array.prototype.slice.call(a, n); }\n","'use strict';\n\nvar ticky = require('ticky');\n\nmodule.exports = function debounce (fn, args, ctx) {\n  if (!fn) { return; }\n  ticky(function run () {\n    fn.apply(ctx || null, args || []);\n  });\n};\n","var si = typeof setImmediate === 'function', tick;\nif (si) {\n  tick = function (fn) { setImmediate(fn); };\n} else {\n  tick = function (fn) { setTimeout(fn, 0); };\n}\n\nmodule.exports = tick;","/**\n * Checks what mouse button or touch gesture was used.\n * @param {PointerEvent} e - The event\n */\n// eslint-disable-next-line consistent-return\nexport default function whichMouseButton(e) {\n  if (e.touches !== undefined) { return e.touches.length; }\n  if (e.which !== undefined && e.which !== 0) { return e.which; } // see https://github.com/bevacqua/dragula/issues/261\n  if (e.buttons !== undefined) { return e.buttons; }\n  const { button } = e;\n  if (button !== undefined) { // see https://github.com/jquery/jquery/blob/99e8ff1baa7ae341e94bb89c3e84570c7c3ad9ea/src/event.js#L573-L575\n    // eslint-disable-next-line no-bitwise,no-nested-ternary\n    return button & 1 ? 1 : button & 2 ? 3 : (button & 4 ? 2 : 0);\n  }\n}\n"],"names":["$parcel$global","globalThis","self","window","global","$661a7c694eb6eb99$exports","$9ab524b3c329eb0b$exports","a","n","Array","prototype","slice","call","$d4df605507cc7329$exports","$0d1c62139db3c1b4$exports","$a14468eb1aae64d2$export$2e2bcd8739ae039","e","undefined","touches","length","which","buttons","button","setImmediate","fn","setTimeout","args","ctx","apply","thing","options","opts","evt","on","type","push","once","_once","off","c","arguments","et","splice","indexOf","emit","emitterSnapshot","shift","throws","forEach","listen","async","$8e24812e2bcd6903$var$doc","document","documentElement","$8e24812e2bcd6903$var$documentElement","$8e24812e2bcd6903$var$getParent","el","parentNode","$8e24812e2bcd6903$var$getImmediateChild","dropTarget","target","immediate","$8e24812e2bcd6903$var$isInput","tagName","$8e24812e2bcd6903$var$isEditable","contentEditable","$8e24812e2bcd6903$var$getCoord","coord","host","targetTouches","changedTouches","missMap","pageX","pageY","coordinateName","$8e24812e2bcd6903$var$getScroll","scrollProp","offsetProp","clientHeight","body","$8e24812e2bcd6903$var$getRectWidth","rect","width","right","left","$8e24812e2bcd6903$var$getRectHeight","height","bottom","top","$8e24812e2bcd6903$var$nextEl","nextElementSibling","manually","sibling","nextSibling","nodeType","$8e24812e2bcd6903$var$getElementBehindPoint","point","x","y","state","className","elementFromPoint","$8e24812e2bcd6903$export$ba43bf67f3d48107","moves","accepts","invalid","containers","isContainer","copy","copySortSource","revertOnSpill","removeOnSpill","direction","ignoreInputTextSelection","mirrorContainer","slideFactorX","slideFactorY","$8e24812e2bcd6903$export$2e2bcd8739ae039","constructor","lastDropTarget","movementBindFn","startBecauseMouseMoved","bind","preventGrabbedFn","preventGrabbed","grabFn","grab","releaseFn","release","dragFn","drag","drake","__esModule","default","start","manualStart","end","cancel","remove","destroy","canMove","dragging","spillOver","spillOut","classList","add","events","removeEventListener","addEventListener","grabbed","preventDefault","movements","getDrake","moveX","clientX","moveY","clientY","metaKey","ctrlKey","item","context","canStart","eventualMovements","focus","ungrab","elementBehindCursor","mirror","findDropTarget","source","drop","Math","abs","offset","$8e24812e2bcd6903$var$getOffset","getBoundingClientRect","offsetX","offsetY","renderMirrorImage","reference","style","changed","parent","removeChild","getReference","initialSibling","currentSibling","insertBefore","cloneNode","appendChild","removeMirrorImage","isCopy","revert","reverts","initial","isInitialPlacement","cleanup","container","isDropTargetAccepted","originalTarget","droppable","s","horizontal","inside","after","outside","children","len","i","handle","dragula","initialContainers","isArray","Object","hasOwnProperty","dragulaObject","Dragula","emitter","whichMouseButton","doc","getParent","getImmediateChild","isEditable","isInput","getEventHost","getCoord","getScroll","getOffset","getRectWidth","getRectHeight","nextEl","getElementBehindPoint","defaultOptions","ignore","resolve","movable"],"version":3,"file":"dragula-min.js.map"}