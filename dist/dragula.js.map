{"mappings":"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","sources":["src/dragula.js","src/Dragula/Dragula.js","node_modules/contra/emitter.js","node_modules/atoa/atoa.js","node_modules/contra/debounce.js","node_modules/ticky/ticky-browser.js","src/Dragula/Mouse.js"],"sourcesContent":["import Dragula from './Dragula/Dragula';\n\nwindow.dragula = (initialContainers, options) => {\n  if (options === undefined && Array.isArray(initialContainers) === false) {\n    // eslint-disable-next-line no-param-reassign\n    options = initialContainers;\n  } else if (Array.isArray(initialContainers)) {\n    if (options === undefined) {\n      // eslint-disable-next-line no-param-reassign\n      options = {};\n    }\n    if (Object.prototype.hasOwnProperty.call(options, 'containers') === false) {\n      // eslint-disable-next-line no-param-reassign\n      options.containers = initialContainers;\n    }\n  }\n\n  const dragulaObject = new Dragula(options);\n  dragulaObject.events();\n  return dragulaObject.getDrake();\n};\n","import emitter from 'contra/emitter';\nimport whichMouseButton from './Mouse';\n\nconst doc = document;\nconst { documentElement } = doc;\n\n/**\n * Get parent of the element. If parent is the root document then null is returned\n * @param   el  {Node}\n * @returns {ParentNode|null}\n */\nfunction getParent(el) { return el.parentNode === doc ? null : el.parentNode; }\n\n/**\n * Get parent of the element. If parent is the root document then null is returned\n * @param   dropTarget  {Node}\n * @param   target      {Node}\n * @returns {ParentNode|null}\n */\nfunction getImmediateChild(dropTarget, target) {\n  let immediate = target;\n  while (immediate !== dropTarget && getParent(immediate) !== dropTarget) {\n    immediate = getParent(immediate);\n  }\n  if (immediate === documentElement) {\n    return null;\n  }\n  return immediate;\n}\n\n/**\n * Get the next sibling of the parameter element\n * @param   el  {HTMLElement}\n * @returns boolean\n */\nfunction isEditable(el) {\n  if (!el) { return false; } // no parents were editable\n  if (el.contentEditable === 'false') { return false; } // stop the lookup\n  if (el.contentEditable === 'true') { return true; } // found a contentEditable element in the chain\n  return isEditable(getParent(el)); // contentEditable is set to 'inherit'\n}\n\n/**\n * Get the next sibling of the parameter element\n * @param   el  {HTMLElement}\n * @returns boolean\n */\nfunction isInput(el) { return el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || isEditable(el); }\n\n/**\n * Get the touch target of the event. Returns the original event if it can't be computed.\n * @param   e  {TouchEvent}\n * @returns Touch|TouchEvent\n */\nfunction getEventHost(e) {\n  // on touchend event, we have to use `e.changedTouches`\n  // see http://stackoverflow.com/questions/7192563/touchend-event-properties\n  // see https://github.com/bevacqua/dragula/issues/34\n  if (e.targetTouches && e.targetTouches.length) {\n    return e.targetTouches[0];\n  }\n  if (e.changedTouches && e.changedTouches.length) {\n    return e.changedTouches[0];\n  }\n  return e;\n}\n\n/**\n * Gets the host co-ordinate for the event.\n * @param   coord  {string}\n * @param   e  {TouchEvent}\n * @returns Touch|TouchEvent\n */\nfunction getCoord(coord, e) {\n  const host = getEventHost(e);\n  const missMap = {\n    pageX: 'clientX', // IE8\n    pageY: 'clientY', // IE8\n  };\n  let coordinateName = coord;\n  if (coord in missMap && !(coord in host) && missMap[coord] in host) {\n    coordinateName = missMap[coord];\n  }\n  return host[coordinateName];\n}\n\nfunction getScroll(scrollProp, offsetProp) {\n  if (typeof global[offsetProp] !== 'undefined') {\n    return global[offsetProp];\n  }\n  if (documentElement.clientHeight) {\n    return documentElement[scrollProp];\n  }\n  return doc.body[scrollProp];\n}\n\nfunction getOffset(el) {\n  const rect = el.getBoundingClientRect();\n  return {\n    left: rect.left + getScroll('scrollLeft', 'pageXOffset'),\n    top: rect.top + getScroll('scrollTop', 'pageYOffset'),\n  };\n}\n\nfunction getRectWidth(rect) { return rect.width || (rect.right - rect.left); }\nfunction getRectHeight(rect) { return rect.height || (rect.bottom - rect.top); }\n\n/**\n * Get the next sibiling of the parameter element\n * @param   el  Element\n * @returns {Element}\n */\nfunction nextEl(el) {\n  function manually() {\n    let sibling = el;\n    do {\n      sibling = sibling.nextSibling;\n    } while (sibling && sibling.nodeType !== 1);\n    return sibling;\n  }\n  return el.nextElementSibling || manually();\n}\n\nfunction getElementBehindPoint(point, x, y) {\n  // eslint-disable-next-line no-param-reassign\n  point = point || {};\n  const state = point.className || '';\n  // eslint-disable-next-line no-param-reassign\n  point.className += ' gu-hide';\n  const el = doc.elementFromPoint(x, y);\n  // eslint-disable-next-line no-param-reassign\n  point.className = state;\n  return el;\n}\n\n/**\n * Default Options for Dragula\n * @property  {function(): boolean} moves\n * @property  {function(): boolean} accepts\n * @property  {function(): boolean} invalid\n * @property  {HTMLElement[]}\n * @property  {function(): boolean} isContainer\n * @property  {boolean|function(): boolean} copy\n * @property  {boolean} copySortSource\n * @property  {boolean} revertOnSpill\n * @property  {boolean} removeOnSpill\n * @property  {string}  direction\n * @property  {boolean} ignoreInputTextSelection\n * @property  {HTMLElement} mirrorContainer\n * @property  {int} slideFactorX\n * @property  {int} slideFactorY\n */\nexport const defaultOptions = {\n  moves: () => true,\n  accepts: () => true,\n  invalid: () => false,\n  containers: [],\n  isContainer: () => false,\n  copy: false,\n  copySortSource: false,\n  revertOnSpill: false,\n  removeOnSpill: false,\n  direction: 'vertical',\n  ignoreInputTextSelection: true,\n  mirrorContainer: doc.body,\n  slideFactorX: 0,\n  slideFactorY: 0,\n};\n\n/**\n * @property {Node} mirror   The mirror image\n * @property {Node} source   The source container\n * @property {Node} item     The item being dragged\n * @property {int}  offsetX  The reference x\n * @property {int}  moveX    The reference move x\n * @property {int}  moveY    The reference move y\n * @property {Element}  initialSibling    The reference sibling when grabbed\n * @property {Element}  currentSibling    The reference sibling now\n * @property {Node}  copy    The item used for copying\n * @property {?Object}  grabbed    Holds mousedown context until first mousemove\n */\nexport default class Dragula {\n  /**\n   * @param {Object} options - Options for dragula\n   */\n  constructor(options = {}) {\n    this.options = {\n      ...defaultOptions,\n      ...options,\n    };\n\n    // Ensure the drop target is init'd to be null from the start\n    this.lastDropTarget = null; // last container item was over\n    this.movementBindFn = this.startBecauseMouseMoved.bind(this);\n    this.preventGrabbedFn = this.preventGrabbed.bind(this);\n    this.grabFn = this.grab.bind(this);\n    this.releaseFn = this.release.bind(this);\n    this.dragFn = this.drag.bind(this);\n\n    this.drake = emitter({\n      containers: this.options.containers,\n      start: this.manualStart.bind(this),\n      end: this.end.bind(this),\n      cancel: this.cancel.bind(this),\n      remove: this.remove.bind(this),\n      destroy: this.destroy.bind(this),\n      canMove: this.canMove.bind(this),\n      dragging: false,\n    });\n\n    if (this.options.removeOnSpill === true) {\n      this.drake.on('over', this.spillOver.bind(this)).on('out', this.spillOut.bind(this));\n    }\n  }\n\n  /**\n   * @param {HTMLElement }el\n   */\n  // eslint-disable-next-line class-methods-use-this\n  spillOver(el) {\n    el.classList.remove('gu-hide');\n  }\n\n  /**\n   * @param {HTMLElement }el\n   */\n  spillOut(el) {\n    if (this.drake.dragging) { el.classList.add('gu-hide'); }\n  }\n\n  /**\n   * Adds the event bindings to the dom\n   * @param {boolean} remove\n   */\n  events(remove = false) {\n    if (remove) {\n      documentElement.removeEventListener('pointerdown', this.grabFn);\n      documentElement.removeEventListener('pointerup', this.releaseFn);\n    } else {\n      documentElement.addEventListener('pointerdown', this.grabFn);\n      documentElement.addEventListener('pointerup', this.releaseFn);\n    }\n  }\n\n  /**\n   * @param {Event} e - Event on grabbing an item\n   */\n  preventGrabbed(e) {\n    if (this.grabbed) {\n      e.preventDefault();\n    }\n  }\n\n  movements(remove) {\n    if (remove) {\n      documentElement.removeEventListener('click', this.preventGrabbedFn);\n    } else {\n      documentElement.addEventListener('click', this.preventGrabbedFn);\n    }\n  }\n\n  getDrake() {\n    return this.drake;\n  }\n\n  /**\n   * Called when picking up an item to drag\n   * @param {PointerEvent} e - The event\n   */\n  grab(e) {\n    this.moveX = e.clientX;\n    this.moveY = e.clientY;\n\n    const ignore = whichMouseButton(e) !== 1 || e.metaKey || e.ctrlKey;\n    if (ignore) {\n      return; // we only care about honest-to-god left clicks and touch events\n    }\n    const item = e.target;\n    const context = this.canStart(item);\n    if (!context) {\n      return;\n    }\n    this.grabbed = context;\n    this.eventualMovements();\n    if (e.type === 'mousedown') {\n      if (isInput(item)) { // see also: https://github.com/bevacqua/dragula/issues/208\n        item.focus(); // fixes https://github.com/bevacqua/dragula/issues/176\n      } else {\n        e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155\n      }\n    }\n  }\n\n  ungrab() {\n    this.grabbed = false;\n    this.eventualMovements(true);\n    this.movements(true);\n  }\n\n  release(e) {\n    this.ungrab();\n\n    if (!this.drake.dragging) {\n      return;\n    }\n    const item = this.copy || this.item;\n    const clientX = getCoord('clientX', e) || 0;\n    const clientY = getCoord('clientY', e) || 0;\n    const elementBehindCursor = getElementBehindPoint(this.mirror, clientX, clientY);\n    const dropTarget = this.findDropTarget(elementBehindCursor, clientX, clientY);\n\n    // eslint-disable-next-line max-len\n    if (dropTarget && ((this.copy && this.options.copySortSource) || (!this.copy || dropTarget !== this.source))) {\n      this.drop(item, dropTarget);\n    } else if (this.options.removeOnSpill) {\n      this.remove();\n    } else {\n      this.cancel();\n    }\n  }\n\n  eventualMovements(remove) {\n    if (remove) {\n      documentElement.removeEventListener('pointermove', this.movementBindFn);\n    } else {\n      documentElement.addEventListener('pointermove', this.movementBindFn);\n    }\n  }\n\n  startBecauseMouseMoved(e) {\n    if (!this.grabbed) {\n      return;\n    }\n    if (whichMouseButton(e) === 0) {\n      this.release({});\n      // eslint-disable-next-line max-len\n      return; // when text is selected on an input and then dragged, mouseup doesn't fire. this is our only hope\n    }\n\n    // truthy check fixes #239, equality fixes #207, fixes #501\n    // eslint-disable-next-line max-len\n    if ((e.clientX !== undefined && Math.abs(e.clientX - this.moveX) <= this.options.slideFactorX)\n      // eslint-disable-next-line max-len\n      && (e.clientY !== undefined && Math.abs(e.clientY - this.moveY) <= this.options.slideFactorY)) {\n      return;\n    }\n\n    if (this.options.ignoreInputTextSelection) {\n      const clientX = getCoord('clientX', e) || 0;\n      const clientY = getCoord('clientY', e) || 0;\n      const elementBehindCursor = doc.elementFromPoint(clientX, clientY);\n      if (isInput(elementBehindCursor)) {\n        return;\n      }\n    }\n\n    const { grabbed } = this; // call to end() unsets _grabbed\n    this.eventualMovements(true);\n    this.movements();\n    this.end();\n    this.start(grabbed);\n\n    const offset = getOffset(this.item);\n    this.offsetX = getCoord('pageX', e) - offset.left;\n    this.offsetY = getCoord('pageY', e) - offset.top;\n\n    const item = this.copy || this.item;\n    item.classList.add('gu-transit');\n    this.renderMirrorImage();\n    this.drag(e);\n  }\n\n  drag(e) {\n    if (!this.mirror) {\n      return;\n    }\n    e.preventDefault();\n\n    const clientX = getCoord('clientX', e) || 0;\n    const clientY = getCoord('clientY', e) || 0;\n    const x = clientX - this.offsetX;\n    const y = clientY - this.offsetY;\n\n    this.mirror.style.left = `${x}px`;\n    this.mirror.style.top = `${y}px`;\n\n    const item = this.copy || this.item;\n    const elementBehindCursor = getElementBehindPoint(this.mirror, clientX, clientY);\n    let dropTarget = this.findDropTarget(elementBehindCursor, clientX, clientY);\n    const changed = dropTarget !== null && dropTarget !== this.lastDropTarget;\n\n    if (changed || dropTarget === null) {\n      if (this.lastDropTarget) { this.drake.emit('out', item, this.lastDropTarget, this.source); }\n      this.lastDropTarget = dropTarget;\n      if (changed) { this.drake.emit('over', item, this.lastDropTarget, this.source); }\n    }\n    const parent = getParent(item);\n    if (dropTarget === this.source && this.copy && !this.options.copySortSource) {\n      if (parent) {\n        parent.removeChild(item);\n      }\n      return;\n    }\n    let reference;\n    const immediate = getImmediateChild(dropTarget, elementBehindCursor);\n    if (immediate !== null) {\n      reference = this.getReference(dropTarget, immediate, clientX, clientY);\n    } else if (this.options.revertOnSpill === true && !this.copy) {\n      reference = this.initialSibling;\n      dropTarget = this.source;\n    } else {\n      if (this.copy && parent) {\n        parent.removeChild(item);\n      }\n      return;\n    }\n    if (\n      (reference === null && changed)\n       || (reference !== item && reference !== nextEl(item))\n    ) {\n      this.currentSibling = reference;\n      dropTarget.insertBefore(item, reference);\n      this.drake.emit('shadow', item, dropTarget, this.source);\n    }\n  }\n\n  renderMirrorImage() {\n    if (this.mirror) {\n      return;\n    }\n    const rect = this.item.getBoundingClientRect();\n    this.mirror = this.item.cloneNode(true);\n    this.mirror.style.width = `${getRectWidth(rect)}px`;\n    this.mirror.style.height = `${getRectHeight(rect)}px`;\n    this.mirror.classList.remove('gu-transit');\n    this.mirror.classList.add('gu-mirror');\n    this.options.mirrorContainer.appendChild(this.mirror);\n    documentElement.addEventListener('pointermove', this.dragFn);\n    this.options.mirrorContainer.classList.add('gu-unselectable');\n    this.drake.emit('cloned', this.mirror, this.item, 'mirror');\n  }\n\n  removeMirrorImage() {\n    if (this.mirror) {\n      this.options.mirrorContainer.classList.remove('gu-unselectable');\n      documentElement.removeEventListener('pointermove', this.dragFn);\n      getParent(this.mirror).removeChild(this.mirror);\n      this.mirror = null;\n    }\n  }\n\n  start(context) {\n    if (this.isCopy(context.item, context.source)) {\n      this.copy = context.item.cloneNode(true);\n      this.drake.emit('cloned', this.copy, context.item, 'copy');\n    }\n\n    this.source = context.source;\n    this.item = context.item;\n    this.initialSibling = nextEl(context.item);\n    this.currentSibling = nextEl(context.item);\n\n    this.drake.dragging = true;\n    this.drake.emit('drag', this.item, this.source);\n  }\n\n  end() {\n    if (!this.drake.dragging) {\n      return;\n    }\n    const item = this.copy || this.item;\n    this.drop(item, getParent(item));\n  }\n\n  cancel(revert) {\n    if (!this.drake.dragging) {\n      return;\n    }\n    const reverts = arguments.length > 0 ? revert : this.options.revertOnSpill;\n    const item = this.copy || this.item;\n    const parent = getParent(item);\n    const initial = this.isInitialPlacement(parent);\n    if (initial === false && reverts) {\n      if (this.copy) {\n        if (parent) {\n          parent.removeChild(this.copy);\n        }\n      } else {\n        this.source.insertBefore(item, this.initialSibling);\n      }\n    }\n    if (initial || reverts) {\n      this.drake.emit('cancel', item, this.source, this.source);\n    } else {\n      this.drake.emit('drop', item, parent, this.source, this.currentSibling);\n    }\n    this.cleanup();\n  }\n\n  cleanup() {\n    const item = this.copy || this.item;\n    this.ungrab();\n    this.removeMirrorImage();\n    if (item) {\n      item.classList.remove('gu-transit');\n    }\n    this.drake.dragging = false;\n    if (this.lastDropTarget) {\n      this.drake.emit('out', item, this.lastDropTarget, this.source);\n    }\n    this.drake.emit('dragend', item);\n    // eslint-disable-next-line max-len,no-multi-assign\n    this.source = this.item = this.copy = this.initialSibling = this.currentSibling = this.lastDropTarget = null;\n  }\n\n  isCopy(item, container) {\n    return typeof this.options.copy === 'boolean' ? this.options.copy : this.options.copy(item, container);\n  }\n\n  isContainer(el) {\n    return this.drake.containers.indexOf(el) !== -1 || this.options.isContainer(el);\n  }\n\n  findDropTarget(elementBehindCursor, clientX, clientY) {\n    let target = elementBehindCursor;\n\n    while (target && !this.isDropTargetAccepted(target, elementBehindCursor, clientX, clientY)) {\n      target = getParent(target);\n    }\n    return target;\n  }\n\n  isDropTargetAccepted(target, originalTarget, clientX, clientY) {\n    const droppable = this.isContainer(target);\n    if (droppable === false) {\n      return false;\n    }\n\n    const immediate = getImmediateChild(target, originalTarget);\n    const reference = this.getReference(target, immediate, clientX, clientY);\n    const initial = this.isInitialPlacement(target, reference);\n    if (initial) {\n      return true; // should always be able to drop it right back where it was\n    }\n    return this.options.accepts(this.item, target, this.source, reference);\n  }\n\n  isInitialPlacement(target, s) {\n    let sibling;\n    if (s !== undefined) {\n      sibling = s;\n    } else if (this.mirror) {\n      sibling = this.currentSibling;\n    } else {\n      sibling = nextEl(this.copy || this.item);\n    }\n    return target === this.source && sibling === this.initialSibling;\n  }\n\n  getReference(dropTarget, target, x, y) {\n    const horizontal = this.options.direction === 'horizontal';\n\n    function resolve(after) {\n      return after ? nextEl(target) : target;\n    }\n\n    function outside() { // slower, but able to figure out any position\n      const { children } = dropTarget;\n      const len = children.length;\n      let el;\n      let rect;\n      // eslint-disable-next-line no-plusplus\n      for (let i = 0; i < len; i++) {\n        el = children[i];\n        rect = el.getBoundingClientRect();\n        if (horizontal && (rect.left + rect.width / 2) > x) { return el; }\n        if (!horizontal && (rect.top + rect.height / 2) > y) { return el; }\n      }\n      return null;\n    }\n\n    function inside() { // faster, but only available if dropped inside a child element\n      const rect = target.getBoundingClientRect();\n      if (horizontal) {\n        return resolve(x > rect.left + getRectWidth(rect) / 2);\n      }\n      return resolve(y > rect.top + getRectHeight(rect) / 2);\n    }\n\n    return target !== dropTarget ? inside() : outside();\n  }\n\n  /**\n   * @param {Node} item - The item being checked\n   */\n  canStart(item) {\n    if (this.drake.dragging && this.mirror) {\n      return;\n    }\n    if (this.isContainer(item)) {\n      return; // don't drag container itself\n    }\n    const handle = item;\n    while (getParent(item) && this.isContainer(getParent(item)) === false) {\n      if (this.options.invalid(item, handle)) {\n        return;\n      }\n      // eslint-disable-next-line no-param-reassign\n      item = getParent(item); // drag target should be a top element\n      if (!item) {\n        return;\n      }\n    }\n    const source = getParent(item);\n    if (!source) {\n      return;\n    }\n    if (this.options.invalid(item, handle)) {\n      return;\n    }\n\n    const movable = this.options.moves(item, source, handle, nextEl(item));\n    if (!movable) {\n      return;\n    }\n\n    // eslint-disable-next-line consistent-return\n    return {\n      item,\n      source,\n    };\n  }\n\n  drop(item, target) {\n    const parent = getParent(item);\n    if (this.copy && this.options.copySortSource && target === this.source) {\n      parent.removeChild(this.item);\n    }\n    if (this.isInitialPlacement(target)) {\n      this.drake.emit('cancel', item, this.source, this.source);\n    } else {\n      this.drake.emit('drop', item, target, this.source, this.currentSibling);\n    }\n    this.cleanup();\n  }\n\n  canMove(item) {\n    return !!this.canStart(item);\n  }\n\n  remove() {\n    if (!this.drake.dragging) {\n      return;\n    }\n    const item = this.copy || this.item;\n    const parent = getParent(item);\n    if (parent) {\n      parent.removeChild(item);\n    }\n    this.drake.emit(this.copy ? 'cancel' : 'remove', item, parent, this.source);\n    this.cleanup();\n  }\n\n  destroy() {\n    this.events(true);\n    this.release({});\n  }\n\n  manualStart(item) {\n    const context = this.canStart(item);\n    if (context) {\n      this.start(context);\n    }\n  }\n}\n","'use strict';\n\nvar atoa = require('atoa');\nvar debounce = require('./debounce');\n\nmodule.exports = function emitter (thing, options) {\n  var opts = options || {};\n  var evt = {};\n  if (thing === undefined) { thing = {}; }\n  thing.on = function (type, fn) {\n    if (!evt[type]) {\n      evt[type] = [fn];\n    } else {\n      evt[type].push(fn);\n    }\n    return thing;\n  };\n  thing.once = function (type, fn) {\n    fn._once = true; // thing.off(fn) still works!\n    thing.on(type, fn);\n    return thing;\n  };\n  thing.off = function (type, fn) {\n    var c = arguments.length;\n    if (c === 1) {\n      delete evt[type];\n    } else if (c === 0) {\n      evt = {};\n    } else {\n      var et = evt[type];\n      if (!et) { return thing; }\n      et.splice(et.indexOf(fn), 1);\n    }\n    return thing;\n  };\n  thing.emit = function () {\n    var args = atoa(arguments);\n    return thing.emitterSnapshot(args.shift()).apply(this, args);\n  };\n  thing.emitterSnapshot = function (type) {\n    var et = (evt[type] || []).slice(0);\n    return function () {\n      var args = atoa(arguments);\n      var ctx = this || thing;\n      if (type === 'error' && opts.throws !== false && !et.length) { throw args.length === 1 ? args[0] : args; }\n      et.forEach(function emitter (listen) {\n        if (opts.async) { debounce(listen, args, ctx); } else { listen.apply(ctx, args); }\n        if (listen._once) { thing.off(type, listen); }\n      });\n      return thing;\n    };\n  };\n  return thing;\n};\n","module.exports = function atoa (a, n) { return Array.prototype.slice.call(a, n); }\n","'use strict';\n\nvar ticky = require('ticky');\n\nmodule.exports = function debounce (fn, args, ctx) {\n  if (!fn) { return; }\n  ticky(function run () {\n    fn.apply(ctx || null, args || []);\n  });\n};\n","var si = typeof setImmediate === 'function', tick;\nif (si) {\n  tick = function (fn) { setImmediate(fn); };\n} else {\n  tick = function (fn) { setTimeout(fn, 0); };\n}\n\nmodule.exports = tick;","/**\n * Checks what mouse button or touch gesture was used.\n * @param {PointerEvent} e - The event\n */\n// eslint-disable-next-line consistent-return\nexport default function whichMouseButton(e) {\n  if (e.touches !== undefined) { return e.touches.length; }\n  if (e.which !== undefined && e.which !== 0) { return e.which; } // see https://github.com/bevacqua/dragula/issues/261\n  if (e.buttons !== undefined) { return e.buttons; }\n  const { button } = e;\n  if (button !== undefined) { // see https://github.com/jquery/jquery/blob/99e8ff1baa7ae341e94bb89c3e84570c7c3ad9ea/src/event.js#L573-L575\n    // eslint-disable-next-line no-bitwise,no-nested-ternary\n    return button & 1 ? 1 : button & 2 ? 3 : (button & 4 ? 2 : 0);\n  }\n}\n"],"names":["Dragula","window","dragula","initialContainers","options","undefined","Array","isArray","Object","prototype","hasOwnProperty","call","containers","dragulaObject","events","getDrake","emitter","whichMouseButton","doc","document","documentElement","getParent","el","parentNode","getImmediateChild","dropTarget","target","immediate","isEditable","contentEditable","isInput","tagName","getEventHost","e","targetTouches","length","changedTouches","getCoord","coord","host","missMap","pageX","pageY","coordinateName","getScroll","scrollProp","offsetProp","global","clientHeight","body","getOffset","rect","getBoundingClientRect","left","top","getRectWidth","width","right","getRectHeight","height","bottom","nextEl","manually","sibling","nextSibling","nodeType","nextElementSibling","getElementBehindPoint","point","x","y","state","className","elementFromPoint","defaultOptions","moves","accepts","invalid","isContainer","copy","copySortSource","revertOnSpill","removeOnSpill","direction","ignoreInputTextSelection","mirrorContainer","slideFactorX","slideFactorY","constructor","lastDropTarget","movementBindFn","startBecauseMouseMoved","bind","preventGrabbedFn","preventGrabbed","grabFn","grab","releaseFn","release","dragFn","drag","drake","start","manualStart","end","cancel","remove","destroy","canMove","dragging","on","spillOver","spillOut","classList","add","removeEventListener","addEventListener","grabbed","preventDefault","movements","moveX","clientX","moveY","clientY","ignore","metaKey","ctrlKey","item","context","canStart","eventualMovements","type","focus","ungrab","elementBehindCursor","mirror","findDropTarget","source","drop","Math","abs","offset","offsetX","offsetY","renderMirrorImage","style","changed","emit","parent","removeChild","reference","getReference","initialSibling","currentSibling","insertBefore","cloneNode","appendChild","removeMirrorImage","isCopy","revert","reverts","arguments","initial","isInitialPlacement","cleanup","container","indexOf","isDropTargetAccepted","originalTarget","droppable","s","horizontal","resolve","after","outside","children","len","i","inside","handle","movable","touches","which","buttons","button"],"version":3,"file":"dragula.js.map"}